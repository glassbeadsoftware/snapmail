{"version":3,"file":"storage.js","sourceRoot":"","sources":["../src/storage.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqIE","sourcesContent":["/*\nimport * as path from 'path'\nimport fs = require('fs');\nimport { log } from './logger';\nimport { app, dialog } from 'electron';\nimport { RUNNING_ZOME_HASH_FILEPATH, DNA_VERSION_FILENAME } from './constants';\n\n/!** *!/\nexport function fatalError(message:string, error: any | undefined) {\n  log('error', message);\n  log('error', error);\n  dialog.showMessageBoxSync({\n    title: 'Snapmail: Fatal error',\n    buttons: ['exit'],\n    type: 'error',\n    message,\n    detail: JSON.stringify(error),\n  });\n  process.abort();\n}\n\n\n/!** *!/\nexport function setupStorage(storagePath: string, runningDnaHash: string): void {\n  const dna_version_txt = path.join(storagePath, DNA_VERSION_FILENAME);\n  /!** Create storage and setup if none found *!/\n  if(!fs.existsSync(storagePath)) {\n    log('info', \"Creating missing dir: \" + storagePath);\n    try {\n      fs.mkdirSync(storagePath);\n      fs.writeFileSync(dna_version_txt, runningDnaHash, 'utf-8');\n    } catch(e) {\n      fatalError('Failed to setup storage folder on disk', e);\n    }\n    return;\n  }\n  /!** Make sure its a compatible version *!/\n  let storedDnaHash = '<not found>';\n  try {\n    log('debug', 'Reading: ' + dna_version_txt);\n    storedDnaHash = fs.readFileSync(dna_version_txt, 'utf-8');\n  } catch(e) {\n    log('error', 'Failed to read the dna_version_txt file !');\n    log('error', e);\n  }\n  if(storedDnaHash !== runningDnaHash) {\n    const msg = \"The data found on disk is for a different version of Snapmail's core:\\n\" +\n      '  Stored data version: ' + storedDnaHash + '\\n' +\n      'This running version: ' + runningDnaHash;\n    log('error', msg);\n    const canErase = promptVersionMismatch(msg);\n    if (canErase) {\n      try {\n        fs.rmdirSync(storagePath, {/!*force: true,*!/ recursive: true});\n        setupStorage(storagePath, runningDnaHash);\n      } catch(e) {\n        fatalError('Failed erasing current stored data', e);\n      }\n    }\n  }\n}\n\n\n/!** *!/\nexport function loadUidList(filePath: string): string[] {\n  let uidList = [];\n  try {\n    /!** -- APP config -- *!/\n    log('info', 'Reading file ' + filePath);\n    const uidListString = fs.readFileSync(filePath).toString();\n    uidList = uidListString.replace(/\\r\\n/g,'\\n').split('\\n');\n    uidList = uidList.filter(function (el) {return el != '';});\n    log('info', {uidList});\n  } catch(err) {\n    if(err.code === 'ENOENT') {\n      log('warn', 'File not found: ' + err);\n    } else {\n      log('warn','Loading config file failed: ' + err);\n    }\n    log('warn','continuing...');\n  }\n  return uidList;\n}\n\n\n/!**\n * @returns dnaHash\n *!/\nexport function loadRunningZomeHash(): string {\n  if(fs.existsSync(RUNNING_ZOME_HASH_FILEPATH)) {\n    return fs.readFileSync(RUNNING_ZOME_HASH_FILEPATH, 'utf-8');\n  }\n  if(fs.existsSync('resources/app/' + RUNNING_ZOME_HASH_FILEPATH)) {\n    return fs.readFileSync('resources/app/' + RUNNING_ZOME_HASH_FILEPATH, 'utf-8');\n  }\n  if(fs.existsSync(app.getAppPath() + '/' + RUNNING_ZOME_HASH_FILEPATH)) {\n    return fs.readFileSync(app.getAppPath() + '/' + RUNNING_ZOME_HASH_FILEPATH, 'utf-8');\n  }\n  fatalError(\"Corrupt installation. Missing zome hash file.\", undefined);\n}\n\n\n/!**\n * Return true if user wants to erase stored data\n *!/\nexport function promptVersionMismatch(message: string): boolean {\n  const result = dialog.showMessageBoxSync({\n    /!*width: 900,*!/\n    title: `${app.getName()} - v${app.getVersion()}`,\n    message: `Version mismatch`,\n    detail: message,\n    type: \"warning\",\n    defaultId: 0,\n    buttons: ['Erase stored data', 'Continue anyway', 'Exit'],\n  });\n  switch (result) {\n    case 0: {\n      return true;\n      break;\n    }\n    case 1: {\n      return false;\n      break;\n    }\n    case 2: {\n      app.exit();\n      break;\n    }\n    default:\n      break;\n  }\n  return false;\n}\n*/\n"]}