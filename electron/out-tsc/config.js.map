{"version":3,"file":"config.js","sourceRoot":"","sources":["../src/config.ts"],"names":[],"mappings":"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","sourcesContent":["// import fs from 'fs';\n// import { spawn, ChildProcessWithoutNullStreams } from 'child_process';\n\nimport { bytesToBase64 } from 'byte-base64';\n\n//import { AdminWebsocket, AppWebsocket, AppStatusFilter } from '@holochain/client';\n//const { AdminWebsocket, AppWebsocket } = require('../holochain-conductor-api');\n\n// import { log } from './logger';\n// import { CURRENT_DIR, SNAPMAIL_APP_ID, DEFAULT_BOOTSTRAP_URL, DEFAULT_PROXY_URL } from './constants';\n// import  path from \"path\";\n// import {NetworkSettings} from \"./networkSettings\";\n\n\n/** Convert holo hash to readable string */\nexport function htos(u8array: number[] | Uint8Array): string {\n  return bytesToBase64(u8array)\n}\n\n//\n// /** Spawn 'lair-keystore' process */\n// export async function spawnKeystore(keystore_bin, storagePath: string): Promise<ChildProcessWithoutNullStreams> {\n//   /** Spawn Keystore */\n//   const bin = keystore_bin;\n//   const lair_dir = winPath(path.join(storagePath, \"keystore\"))\n//   const args = ['-d', lair_dir];\n//   log('info', 'Spawning ' + bin + ' (dirname: ' + CURRENT_DIR + ') | spawnKeystore()');\n//   const keystore_proc = spawn(bin, args, {\n//     cwd: CURRENT_DIR,\n//     detached: false,\n//     //stdio: 'pipe',\n//     env: {\n//       ...process.env,\n//     },\n//   });\n//   /** Handle Outputs */\n//   /** Wait for holochain to boot up */\n//   const promise: Promise<void> = new Promise((resolve, reject) => {\n//     keystore_proc.stdout.on('data', (data) => {\n//       log('info', 'lair-keystore: ' + data.toString());\n//       if(data.toString().indexOf(LAIR_MAGIC_READY_STRING) > -1) {\n//         resolve();\n//       }\n//     });\n//     keystore_proc.stderr.on('data', (data) => {\n//       log('error', 'lair-keystore> ' + data.toString())\n//     });\n//     /** Handle Termination */\n//     keystore_proc.on('exit', (code) => {\n//        log('info', code);\n//       reject();\n//       // TODO: Figure out if must kill app if keystore crashes\n//       // kill(holochain_handle.pid, function (err) {\n//       //   if (!err) {\n//       //     log('info', 'killed all holochain sub processes');\n//       //   } else {\n//       //     log('error', err);\n//       //   }\n//       // });\n//       // quit = true;\n//       // app.quit();\n//     });\n//   });\n//   await promise;\n//   /** Done */\n//   return keystore_proc;\n// }\n\n\n/** Sanitize path for Windows */\nexport function winPath(path: string) {\n  if (process.platform !== \"win32\") {\n    return path;\n  }\n  return path.replace(/\\\\/g, \"\\\\\\\\\");\n}\n\n//\n// /**\n//  * Write the conductor config to storage path\n//  * Using proxy and bootstrap server\n//  */\n// export function generateConductorConfig(\n//   configPath: string,\n//   storagePath: string,\n//   adminPort: number,\n//   networkSettings: NetworkSettings): void\n// {\n//   log('info', 'generateConductorConfig() with admin port ' + adminPort);\n//\n//   if (networkSettings.proxyUrl === undefined || networkSettings.proxyUrl === '') {\n//     networkSettings.proxyUrl = DEFAULT_PROXY_URL;\n//   }\n//   let network_type = \"quic_bootstrap\";\n//   if (networkSettings.canMdns) {\n//     network_type = \"quic_mdns\";\n//   }\n//   if (networkSettings.bootstrapUrl === undefined) {\n//     networkSettings.bootstrapUrl = DEFAULT_BOOTSTRAP_URL;\n//   }\n//   const environmentPath = winPath(storagePath);\n//   log('debug',{environmentPath});\n//   const keystorePath = winPath(path.join(environmentPath, \"keystore\"))\n//   log('debug',{keystorePath});\n//\n//   let config;\n//   if (networkSettings.canProxy) {\n//     /** Basic Config with Proxy */\n//     config = `---\n// environment_path: ${environmentPath}\n// keystore:\n//   type: lair_server_legacy_deprecated\n//   keystore_path: \"${keystorePath}\"\n//   danger_passphrase_insecure_from_config: default-insecure-passphrase\n// dpki: ~\n// admin_interfaces:\n//   - driver:\n//       type: websocket\n//       port: ${adminPort}\n// db_sync_level: Normal\n// network:\n//   network_type: ${network_type}\n//   bootstrap_service: ${networkSettings.bootstrapUrl}\n//   transport_pool:\n//     - type: proxy\n//       sub_transport:\n//         type: quic\n//         bind_to: kitsune-quic://0.0.0.0:0\n//         override_host: ~\n//         override_port: ~\n//       proxy_config:\n//         type: remote_proxy_client\n//         proxy_url: ${networkSettings.proxyUrl}\n//         `;\n// } else {\n//     /** No PROXY Config */\n//     config =`---\n// environment_path: \"${environmentPath}\"\n// keystore:\n//   type: lair_server_legacy_deprecated\n//   keystore_path: \"${keystorePath}\"\n//   danger_passphrase_insecure_from_config: default-insecure-passphrase\n// dpki: ~\n// admin_interfaces:\n//   - driver:\n//       type: websocket\n//       port: ${adminPort}\n// db_sync_level: Normal\n// network:\n//   network_type: ${network_type}\n//   bootstrap_service: ${networkSettings.bootstrapUrl}\n//   transport_pool:\n//     - type: quic\n//       bind_to: ~\n//       override_host: ~\n//       override_port: ~\n//       `;\n//   }\n//\n//   fs.writeFileSync(configPath, config);\n// }\n\n//\n// /**\n//  *\n//  * @returns {{networkSettings: {bootstrapUrl: string, proxyUrl: string, canProxy: boolean, canMdns: boolean}, adminPort: number}}\n//  */\n// export function loadConductorConfig(conductorConfigFilePath) {\n//   let canMdns;\n//   let canProxy = true;\n//   let bootstrapUrl;\n//   let proxyUrl;\n//   let adminPort = 0;\n//   try {\n//     /** -- Conductor Config -- */\n//     const conductorConfigBuffer = fs.readFileSync(conductorConfigFilePath);\n//     const conductorConfig = conductorConfigBuffer.toString();\n//     // log('debug', {conductorConfig})\n//     /** Get Admin PORT */\n//     let regex = /port: (.*)$/gm;\n//     let match = regex.exec(conductorConfig);\n//     // log('silly', {match});\n//     adminPort = parseInt(match[1]);\n//     /** Get network type */\n//     regex = /network_type: (.*)$/gm;\n//     match = regex.exec(conductorConfig);\n//     canMdns = match[1] == 'quic_mdns';\n//     /** Get bootstrap server URL */\n//     regex = /bootstrap_service: (.*)$/gm;\n//     match = regex.exec(conductorConfig);\n//     // log('silly', {match});\n//     bootstrapUrl = match[1];\n//     /** Get proxy server URL */\n//     try {\n//       regex = /proxy_url: (.*)$/gm;\n//       match = regex.exec(conductorConfig);\n//       proxyUrl = match[1];\n//       canProxy = true;\n//       log('debug',{ proxyUrl });\n//     } catch(err) {\n//       log('info', 'No proxy URL found in config. Using default proxy.');\n//       proxyUrl = DEFAULT_PROXY_URL;\n//     }\n//   } catch(err) {\n//     if(err.code === 'ENOENT') {\n//       log('error', 'File not found: ' + err);\n//     } else {\n//       log('error','Loading config file failed: ' + err);\n//     }\n//     log('error','continuing...');\n//   }\n//\n//   const networkSettings = {\n//     canMdns, bootstrapUrl, canProxy, proxyUrl\n//   };\n//   return {\n//     networkSettings,\n//     adminPort\n//   };\n// }\n\n// async function isAppInstalled(appPort) {\n//   const adminWs = await AdminWebsocket.connect(`ws://localhost:${adminPort}`);\n//   log('info', 'Connected to admin at ' + adminPort);\n//   const dnas = await adminWs.listDnas();\n//   log('info', 'Found ' + dnas.length + ' dnas');\n// }\n\n//\n// /** */\n// export async function connectToAdmin(adminPort: number): Promise<AdminWebsocket> {\n//   log('info','Connecting to admin at ' + adminPort + ' ...');\n//   let adminWs = undefined\n//   //try {\n//     adminWs = await AdminWebsocket.connect(`ws://localhost:${ adminPort }`, 60 * 1000);\n//     //log('debug',{adminWs});\n//     log('info', 'Connected to admin at ' + adminPort + ' !');\n//   //} catch (e) {\n//   //  log('error', 'Failed to to connect to admin at ' + adminPort + ': ' + e);\n//   //}\n//   return adminWs;\n// }\n//\n//\n// /** */\n// export async function connectToApp(appPort: string): Promise<AppWebsocket> {\n//   let appWs = undefined\n//   //try {\n//     appWs = await AppWebsocket.connect(`ws://localhost:${ appPort }`, 30000);\n//   //log('silly',{appWs});\n//   log('info','Connected to app at ' + appPort);\n//   //} catch (e) {\n//   //  log('error', 'Failed to to connect to app at ' + appPort + ': ' + e);\n//   //}\n//   return appWs;\n// }\n//\n//\n// /** */\n// export async function getDnaHash(adminWs: AdminWebsocket, uid: string): Promise<string|undefined> {\n//   const apps = await adminWs.listApps({status_filter: AppStatusFilter.Running });\n//   log('info','getDnaHash('+ uid +') - Found ' + apps.length + ' app(s):');\n//   for (const app of apps) {\n//     log('info',' -  ' + app.installed_app_id);\n//     for (const cell of app.cell_data) {\n//       // log('info','    -  ' + cell.role_id);\n//       log('info','    -  ' + htos(cell.cell_id[0]));\n//       if (cell.role_id === uid) {\n//         log('info','Found cell:' + htos(cell.cell_id[0]));\n//         //log('info','  0. ' + htos(cell.cell_id[0]));\n//         //log('info','  1. ' + htos(cell.cell_id[1]));\n//         return htos(cell.cell_id[0]);\n//       }\n//     }\n//   }\n//   return undefined;\n// }\n//\n//\n// /**\n//  * Returns port of active app is there is one\n//  */\n// export async function hasActivatedApp(adminWs: AdminWebsocket): Promise<number> {\n//   const dnas = await adminWs.listDnas();\n//   log('debug','Found ' + dnas.length + ' dna(s)');\n//   for (const dna of dnas) {\n//     log('debug',' -  ' + dna); //htos()\n//   }\n//\n//   /** Active Apps */\n//   const activeApps = await adminWs.listApps({status_filter: AppStatusFilter.Enabled});\n//   log('info','Found ' + activeApps.length + ' Active App(s)');\n//   for (const activeApp of activeApps) {\n//     log('info',' -  ' + activeApp.installed_app_id);\n//   }\n//   // const hasActiveApp = activeAppIds.length == 1 && activeAppIds[0] == SNAPMAIL_APP_ID;\n//   const hasActiveApp = activeApps.length > 0;\n//\n//   /** Get App interfaces */\n//   let activeAppPort = 0;\n//   if (hasActiveApp) {\n//     const interfaces = await adminWs.listAppInterfaces();\n//     if (interfaces.length > 0) {\n//       activeAppPort = interfaces[0];\n//     }\n//     log('info','Found ' + interfaces.length + ' App Interfaces(s)');\n//     for (const appInterface of interfaces) {\n//       log('info',' -  ' + appInterface);\n//     }\n//   }\n//   return activeAppPort;\n// }\n\n//\n// /**\n//  * Uninstall current App and reinstall with new uid\n//  */\n// export async function cloneCell(adminWs, uid) {\n//   log('debug', 'cloneCell()');\n//\n//   /** Check if cell exists */\n//   const cellIds = await adminWs.listCellIds();\n//   log('info', 'Found ' + cellIds.length + ' Cell(s)');\n//   for (const cellId of cellIds) {\n//     log('info', ' -  ' + htos(cellId[0]) + ' - ' + htos(cellId[1]));\n//   }\n//   if (cellIds.length === 0) {\n//     log('error', \"Can't switch cell since no cell already installed\");\n//     return false;\n//   }\n//\n//   const firstCellId = cellIds[0];\n//\n//   /** Create it by cloning */\n//   try {\n//     const clonedDna = await adminWs.createCloneCell({\n//       properties: undefined,\n//       dna_hash: firstCellId[0],\n//       agent_key: firstCellId[1],\n//       installed_app_id: SNAPMAIL_APP_ID,\n//       slot_id: uid,\n//       membrane_proof: undefined,\n//     });\n//     log('debug', clonedDna);\n//   } catch (err) {\n//     log('error', 'createCloneCell() failed:');\n//     log('error',{err});\n//   }\n//   /** Done */\n//   return true;\n// }\n\n//\n// /**\n//  *  Connect to Admin interface, install App and attach a port\n//  */\n// export async function installApp(adminWs: AdminWebsocket, uid: string): Promise<string> {\n//   //const installed_app_id = SNAPMAIL_APP_ID;\n//   const installed_app_id = SNAPMAIL_APP_ID + '-' + uid;\n//   log('info', '     Installing  app: ' + installed_app_id);\n//   /** Generate keys */\n//   const myPubKey = await adminWs.generateAgentPubKey();\n//   /** Register Dna */\n//   let hash = undefined;\n//   try {\n//     hash = await adminWs.registerDna({\n//       uid,\n//       properties: undefined,\n//       path: './bin/snapmail.dna',\n//     });\n//   } catch (err) {\n//     log('error','[admin] registerDna() failed:');\n//     log('error',{err});\n//     return;\n//   }\n//   log('info','registerDna response: ' + htos(hash));\n//   /** Install Dna */\n//   try {\n//     const installResponse = await adminWs.installApp({\n//       agent_key: myPubKey,\n//       installed_app_id,\n//       dnas: [{\n//         hash,\n//         role_id: uid,\n//       }],\n//     });\n//     log('debug','Install app response:');\n//     log('debug',{installResponse});\n//   } catch (err) {\n//     log('error','[admin] installApp() failed:');\n//     log('error',{err});\n//     return;\n//   }\n//   log('info','App installed');\n//   await adminWs.enableApp({ installed_app_id });\n//   log('info','App activated');\n//   return htos(hash);\n// }\n"]}